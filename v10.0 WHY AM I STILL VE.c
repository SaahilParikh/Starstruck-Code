#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  hangLock,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  liftBottom,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveLeftFront, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           liftRightEnc,  tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           liftLeftIn,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftRightTop,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftLeftTop,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftRightIn,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftLeftEnc,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          driveRightFront, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


int releaseThreshold = 400; // needs to be set correctly later
int heightThreshold = 17;
int pickUpSpeed = 90;

//Competition Control and Duration Setting

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

task liftHolder()
{
	while(1==1)
	{
			motor[liftLeftEnc] = heightThreshold;
			motor[liftLeftIn] = heightThreshold;
			motor[liftLeftTop] = heightThreshold;
			motor[liftRightEnc] = heightThreshold;
			motor[liftRightIn] = heightThreshold;
			motor[liftRightTop] = heightThreshold;
			wait1Msec(50);
	}
}
// Functions Start Here //


//Clear Function//

void clearGyro()
{
	SensorValue(gyro) = 0;
}

void clearDrive()
{
	nMotorEncoder[driveLeftBack] = 0;
	nMotorEncoder[driveRightBack] = 0;
	// I Guess this works...
}

void clearLift()
{
	nMotorEncoder[liftLeftEnc] = 0;
	nMotorEncoder[liftRightEnc] = 0;
}

void clearAllEncoder()
{
	clearDrive();
	clearLift();
}

//Hault Function//

void haultDrive( int time )
{
	motor[driveRightFront] = 0;
	motor[driveRightBack] = 0;
	motor[driveLeftFront] = 0;
	motor[driveLeftBack] = 0;
	wait1Msec(time);
}

void haultLift( int time )
{
	motor[liftLeftEnc] = 0;
	motor[liftLeftIn] = 0;
	motor[liftLeftTop] = 0;
	motor[liftRightEnc] = 0;
	motor[liftRightIn] = 0;
	motor[liftRightTop] = 0;
	wait1Msec(time);
}

void haultAll(int time)
{
	haultDrive(time);
	haultLift(time);
}

//Piston Function//

void closeClaw()
{
	SensorValue(claw) = 0;
}

void openClaw()
{
	SensorValue(claw) = 1;
}

void lockHang()
{
	SensorValue(hangLock) = 0;
}

void unlockHang()
{
	SensorValue(hangLock) = 1;
}

#warning "is the pickup speed good?"

void pickUp()
{
	closeClaw();

	motor[liftLeftEnc] = 127;
	motor[liftLeftIn] = 127;
	motor[liftLeftTop] = 127;
	motor[liftRightEnc] = 127;
	motor[liftRightIn] = 127;
	motor[liftRightTop] = 127;
	wait1Msec(50);
}
//Drive Funnction//




void driveForwardPid(int Encoder, int minSpeed = 20)
{
	double kP = 0.6;
	double kI = 0.001;
	double kD = 0.8;

	int integral;
	int der;
	int error;
	int prevErr;

	int speed;
	int bias = 3;
	int threshold = 5; // TUNE THIS VALUE - 2/13/2017

	#warning "Tune Autocorrection Threshhold - 2/13/2017";

	while(nMotorEncoder[driveRightBack] < Encoder && nMotorEncoder[driveLeftBack] < Encoder)
	{
		error = ((Encoder - -nMotorEncoder[driveRightBack])+(Encoder - nMotorEncoder[driveLeftBack]))/2 ; //error is both encoder values

		if(error > 100)
		{
			integral = 0;
		}
		else
		{
			integral += error;
		}

		der = prevErr - error;
		prevErr = error;

		speed = ((int)(error*kp + integral*ki + der*kd) > minSpeed)?(int)(error*kp+integral*ki+der*kd):minSpeed;

		if(abs(nMotorEncoder[driveRightBack]) < abs(nMotorEncoder[driveLeftBack])-threshold) // If the left side has more encoder ticks than the right
		{																																			// Make the right side faster, Has bias
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed/bias;
			motor[driveLeftBack] = speed/bias;
		}
		else if(abs(nMotorEncoder[driveRightBack])-threshold > abs(nMotorEncoder[driveLeftBack]))	// Other  way around from top comment
		{
			motor[driveRightFront] = speed/bias;
			motor[driveRightBack] = speed/bias;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		else
		{
			motor[driveRightFront] = speed; 																				// Go normal speed value
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		}
}

void driveBackwardPid(int Encoder, int minSpeed = -90)
{

	double kP = 0.6;
	double kI = 0.001;
	double kD = 0.8;

	int integral;
	int der;
	int error;
	int prevErr;

	int speed;
	int bias = 3;
	int threshold = 2; // TUNE THIS VALUE - 2/13/2017

	#warning "Tune Autocorrect Threshhold - 2/13/2017";

	while(nMotorEncoder[driveRightBack] > -Encoder && nMotorEncoder[driveLeftBack] > -Encoder)
	{
		error = ((-Encoder - -nMotorEncoder[driveRightBack])+(-Encoder - nMotorEncoder[driveLeftBack]))/2 ; //error is both encoder values

		if(error < -100)
		{
			integral = 0;
		}
		else
		{
			integral += error;
		}

		der = prevErr - error;
		prevErr = error;

		speed = ((int)(error*kp + integral*ki + der*kd) > minSpeed)?(int)(error*kp+integral*ki+der*kd):minSpeed;

		if(abs(nMotorEncoder[driveRightBack])-threshold < abs(nMotorEncoder[driveLeftBack])) // If the left side has more encoder ticks than the right
		{																																			// Make the right side faster, Has bias
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed/bias;
			motor[driveLeftBack] = speed/bias;
		}
		else if(abs(nMotorEncoder[driveRightBack]) >abs( nMotorEncoder[driveLeftBack])-threshold)	// Other  way around from top comment
		{
			motor[driveRightFront] = speed/bias;
			motor[driveRightBack] = speed/bias;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		else
		{
			motor[driveRightFront] = speed; 																				// Go normal speed value
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		}
}

void driveEnc(int speed, int Encoder)
{
	int bias = 3;
	while (nMotorEncoder[driveLeftBack] < Encoder || nMotorEncoder[driveRightBack] < Encoder)
	{
		if (SensorValue(gyro) > 10)
		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed/bias;
			motor[driveLeftBack] = speed/bias;
		}
		else if (SensorValue(gyro) < 10)
		{
			motor[driveRightFront] = speed/bias;
			motor[driveRightBack] = speed/bias;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		else
		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
	}
}

void driveTime(int speed, int time)
{
	motor[driveRightFront] = speed;
	motor[driveRightBack] = speed;
	motor[driveLeftFront] = speed;
	motor[driveLeftBack] = speed;
	wait1Msec(time);
}


void drive(int rightSide, int leftSide, int time)
{
	motor[driveRightFront] = rightSide;
	motor[driveRightBack] = rightSide;
	motor[driveLeftFront] = leftSide;
	motor[driveLeftBack] = leftSide;
	wait1Msec(time);
}


void gyroTurn(int degrees, char direction, int minSpeed = 30)
{
	int dir = 1;
	if (direction == 'l' || direction == 'L')
	{
		dir = -1;
	}


	double kP = 0.14;
	double kI = 0.0002;
	double kD = 0.8;

	int integral;
	int der;
	int error;
	int prevErr;
	int speed;
	int bias = 3;


	int stationaryCount = 0;
	int stationaryCountLimit = 3000;
	bool targetReached = false;

	while(!targetReached)
	{
		error = ((dir)*degrees - SensorValue(gyro));  // Using YAW Rate Gyroscope to find the error: units/ticks away from the target
		if(abs(error) > 130 || abs(error)<20)
		{
			integral = 0;
		}
		else
		{
			integral += error;
		}
		der = error - prevErr;
		prevErr = error;

		//speed = ((int)(error*kp + integral*ki + der*kd) > minSpeed)?(int)(error*kp+integral*ki+der*kd):minSpeed;
	speed = (error*kp + integral*ki + der*kd);


		motor[driveRightFront] = speed;
		motor[driveRightBack] = speed;
		motor[driveLeftFront] = -speed;
		motor[driveLeftBack] = -speed;

		if(abs(error) < 30) // TUNE THIS VALUE - 2/13/2017
		{
			stationaryCount += 1;
		}
		else
		{
			stationaryCount = 0;
		}
		if(stationaryCount > stationaryCountLimit) // If robot has been within desired range for long enoungh, end loop and fuction
		{
			targetReached = true;
		}
	}


}

void curlOut(int backUpDistance, int rightSidePower, int leftSidePower)
{
		driveBackwardPid(backUpDistance);
		haultDrive(10);
		clearDrive();
		while(SensorValue(gyro) > -900)
		{
			motor[driveLeftBack] = leftSidePower;
			motor[driveLeftFront] = leftSidePower;
			motor[driveRightBack] = rightSidePower;
			motor[driveRightFront] = rightSidePower;
		}
}

//Lift Function//
void liftTime(int speed, int time)
{
	motor[liftLeftEnc] = speed;
	motor[liftLeftIn] = speed;
	motor[liftLeftTop] = speed;
	motor[liftRightEnc] = speed;
	motor[liftRightIn] = speed;
	motor[liftRightTop] = speed;
	wait1Msec(time);
}

void liftEnc(int speed, int Enc)
{
	while(nMotorEncoder[liftLeftEnc] < Enc && nMotorEncoder[liftRightEnc] < Enc)
	{
		motor[liftLeftEnc] = speed;
		motor[liftLeftIn] = speed;
		motor[liftLeftTop] = speed;
		motor[liftRightEnc] = speed;
		motor[liftRightIn] = speed;
		motor[liftRightTop] = speed;
	}
}

void lift2Bottom()
{
	while(SensorValue(liftBottom) != 1)
	{
		motor[liftLeftEnc] = -107;
		motor[liftLeftIn] = -107;
		motor[liftLeftTop] = -107;
		motor[liftRightEnc] = -107;
		motor[liftRightIn] = -107;
		motor[liftRightTop] = -107;
	}
	clearLift();
}

//Game Specific//

#warning "CHANGE THE BIAS BELOW";
void score(int distance)
{
	int bias = -150;
	while((nMotorEncoder[liftLeftEnc] < 700 || nMotorEncoder[liftRightEnc] < 700 )
		&& (nMotorEncoder[driveLeftBack] <distance|| nMotorEncoder[driveRightBack] < distance))
	{
		if(nMotorEncoder[liftLeftEnc] < releaseThreshold-bias || nMotorEncoder[liftRightEnc] < releaseThreshold-bias)
		{
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}
		else
		{
			openClaw();
			motor[liftLeftEnc] = 70;
			motor[liftLeftIn] = 70;
			motor[liftLeftTop] = 70;
			motor[liftRightEnc] = 70;
			motor[liftRightIn] = 70;
			motor[liftRightTop] = 70;
		}
		if(nMotorEncoder[driveLeftBack] <distance|| nMotorEncoder[driveRightBack] < distance)
		{
			motor[driveRightFront] = -127;
			motor[driveRightBack] = -127;
			motor[driveLeftFront] = -127;
			motor[driveLeftBack] = -127;
		}
		else
		{
			motor[driveRightFront] = -40;
			motor[driveRightBack] = -40;
			motor[driveLeftFront] = -40;
			motor[driveLeftBack] = -40;
		}
	}
	openClaw();
}

void score2(int enc)
{
	int speed = -127;
	int bias = 3;
	int liftB = -250;
	while(nMotorEncoder[liftLeftEnc] < releaseThreshold-liftB || nMotorEncoder[driveLeftBack] <Enc)
	{
		if(nMotorEncoder[driveLeftBack] <Enc)
			{
					if(abs(nMotorEncoder[driveRightBack])-40 < abs(nMotorEncoder[driveLeftBack])) // If the left side has more encoder ticks than the right
						{																																			// Make the right side faster, Has bias
							motor[driveRightFront] = speed;
							motor[driveRightBack] = speed;
							motor[driveLeftFront] = speed/bias;
							motor[driveLeftBack] = speed/bias;
						}
					else if(abs(nMotorEncoder[driveRightBack]) >abs( nMotorEncoder[driveLeftBack])-40)	// Other  way around from top comment
						{
							motor[driveRightFront] = speed/bias;
							motor[driveRightBack] = speed/bias;
							motor[driveLeftFront] = speed;
							motor[driveLeftBack] = speed;
						}
					else
						{
							motor[driveRightFront] = speed; 																				// Go normal speed value
							motor[driveRightBack] = speed;
							motor[driveLeftFront] = speed;
							motor[driveLeftBack] = speed;
						}
			}
		else
			{
							motor[driveRightFront] = 0; 																				// Go normal speed value
							motor[driveRightBack] = 0;
							motor[driveLeftFront] = 0;
							motor[driveLeftBack] = 0;
			}
		if(	nMotorEncoder[liftLeftEnc] < releaseThreshold)
			{
				if(nMotorEncoder[liftLeftEnc] < releaseThreshold-liftB || nMotorEncoder[liftRightEnc] < releaseThreshold-liftB)
					{
					motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}
		else
		{
			openClaw();
			motor[liftLeftEnc] = 0;
			motor[liftLeftIn] = 0;
			motor[liftLeftTop] = 0;
			motor[liftRightEnc] = 0;
			motor[liftRightIn] = 0;
			motor[liftRightTop] = 0;
		}


			}


			}
	}

void score3()
{
	while(nMotorEncoder[liftLeftEnc] < releaseThreshold+150 || nMotorEncoder[liftRightEnc] < releaseThreshold+150)
		{
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}

			motor[driveLeftBack] = -127;
			motor[driveLeftFront] = -127;
			motor[driveRightBack] = -127;
			motor[driveRightFront] = -127;

			openClaw();
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
			wait1Msec(200);



}

void hangFromGround()
{
	motor[driveRightFront] = 127;
	motor[driveRightBack] = 127;
	motor[driveLeftFront] = 127;
	motor[driveLeftBack] = 127;
	wait1Msec(1000);

	while(SensorValue(liftBottom) != 1)
	{
		motor[liftLeftEnc] = -127;
		motor[liftLeftIn] = -127;
		motor[liftLeftTop] = -127;
		motor[liftRightEnc] = -127;
		motor[liftRightIn] = -127;
		motor[liftRightTop] = -127;
	}

	lockHang();



}

// Functions End//


//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------
int count = 0;
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	// bStopTasksBetweenModes = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Declare count variable to keep track of our choice

	//Loop while center button is not pressed
	bool auton = false;

#warning "true is diabled    false is enabled check this tmmr"

	while(!auton)
	{
		if(bIfiRobotDisabled) // true is diabled false is enabled check this tmmr
		{
			//Switch case that allows the user to choose from 4 different options
			switch(count){
			case 0:
				//Display first choice
				displayLCDCenteredString(0, "Game  ||  Skills");
				displayLCDCenteredString(1, "   Team 3050A   ");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 100;
				}
				break;
			case 100:
				//Display second choice
				displayLCDCenteredString(0, "  Enter Skills? ");
				displayLCDCenteredString(1, "Enter Back Enter");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
					auton = true;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
					auton = true;

				}
				else if (nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 0;

				}
				break;
			case 1:
				//Display third choice
				displayLCDCenteredString(0, "    Auton 1    ");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count++;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					auton = true;
				}
				break;
			case 2:
				//Display fourth choice
				displayLCDCenteredString(0, "     left     ");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					auton = true;
				}
				break;
			default:
				count = 0;
				break;

			}
		}
		else
		{
			auton = true;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Prog Skills");
		displayLCDCenteredString(1, "is running!");

		int UH = 50;                                     // Universal Haults

		clearDrive();
		clearGyro();                                     // Clear
		clearLift();

		openClaw();                                      // Deploy
		haultAll(500);                                   // Wait until claw actually falls

		clearDrive();
		driveForwardPid(1050, 100);                        // Forward
		haultDrive(UH);
		clearDrive();

		pickUp();
		haultAll(100);																   // Lift 3 or 4 stars
		clearGyro();
		startTask(liftHolder);

		motor[driveLeftBack] = -127;
		motor[driveLeftFront] = -127;
		motor[driveRightBack] = -127;
		motor[driveRightFront] = -127;
		wait1Msec(400);
		clearDrive();
		curlOut(450, -120, -20);
		motor[driveLeftBack] = -127;
		motor[driveLeftFront] = -127;
		motor[driveRightBack] = 127;
		motor[driveRightFront] = 127;
		wait1msec(40);																	// Hopefully this works - will have to change numbers - biggest tune prpbabkly - Right Turn
		clearDrive();
		haultDrive(UH+1000);

	//	driveForwardPid(300);
	//	haultDrive(10);
	//	clearDrive();
  //
	//	driveBackwardPid(200, -40);                    // If the robot needs to move backward before the score function to get close to the fence then do this
	//	haultDrive(10);

		clearLift();
		clearDrive();
		stopTask(liftHolder);
		driveBackwardPID(300);																			 // Important Score Function - might have to change number
		driveTime(-127, 700);
		haultDrive(10);
		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 200);
		haultDrive(10)

		haultAll(UH);
		clearDrive();
		lift2Bottom();
		haultLift(UH);
		clearLift();

		driveTime(-127, 500);
		haultDrive(10);

		clearDrive();
		driveForwardPid(1000);                            // Get to starting tile to load
		haultDrive(300);
		clearDrive();

		pickUp();
		startTask(liftHolder);													 // First preload
    driveBackwardPid(600);
    haultDrive(UH);
    clearLift();
		clearDrive();
    stopTask(liftHolder);
    driveTime(-127, 500);
		haultDrive(10);
		clearLift();

		score3();
		haultLift(10);


    haultAll(UH);
    clearDrive();
    lift2Bottom();
		haultLift(UH);
		clearLift();

		driveTime(-127, 500);
		haultDrive(10);

		clearDrive();
    driveForwardPid(1000);                            // Get to starting tile to load 2nd time
		haultDrive(300);
		clearDrive();

		pickUp();                                        // Second preload
		startTask(liftHolder);
    driveBackwardPid(600, -60);
    haultDrive(UH);
    clearLift();
		clearDrive();
    stopTask(liftHolder);

    driveTime(-127, 300);
		haultDrive(10);
		clearLift();

		score3();
		haultLift(10);

    haultAll(UH);
    clearDrive();
    lift2Bottom();
		haultLift(UH);
		clearLift();

		driveTime(-127, 500);
		haultDrive(10);

		clearDrive();
		driveForwardPid(1000);                            // Get to starting tile to load 3nd time ***
		haultDrive(300);
		clearDrive();

		pickUp();                                        // Third preload ***
    startTask(liftHolder);
    driveBackwardPid(600, -60);
    haultDrive(UH);
    clearLift();
		clearDrive();
    stopTask(liftHolder);

    driveTime(-127, 300);
		haultDrive(10);
		clearLift();

		score3();
		haultLift(10);

    haultAll(UH);
    clearDrive();
    lift2Bottom();
		haultLift(UH);
		clearLift();

		driveTime(-127, 500);
		haultDrive(10);

		clearDrive();
		driveForwardPid(580);                            // Forward to line up with middle cube
		haultDrive(UH);
		clearDrive();
		clearGyro();
		liftTime(127, 450);
		haultLift(10);

		gyroTurn(900, 'r');                             // Turn left to line up with cube
		haultDrive(UH);
		clearDrive();

		driveForwardPid(2200, 110);                     // Drive into Cube
		haultDrive(UH);
		clearDrive();
		pickUp();
		liftTime(127, 500);
																										// Pick cube up
		startTask(liftHolder);

		haultDrive(1000);

		clearGyro();
		gyroTurn(1000, 'l');
		haultAll(100);
		motor[driveLeftBack] = 127;
		motor[driveLeftFront] = 127;
		motor[driveRightBack] = -127;
		motor[driveRightFront] = -127;
		wait1msec(20);

		haultDrive(1000);
		clearLift();
		clearDrive();																		 // Turn, back to the fence
    stopTask(liftHolder);

    driveBackwardPid(500);

    driveTime(-127, 300);
		haultDrive(10);
		lift2Bottom();
		haultAll(UH);
		clearLift();

		score3();
		haultLift(10);

    // Score
    haultAll(UH);
    clearDrive();
    lift2Bottom();
		haultLift(UH);
		clearLift();

		clearDrive();
		driveForwardPid(1100);                            // Go for Second Ground Cube
		haultDrive(UH+300);
		pickUp();
		startTask(liftHolder);
		clearDrive();
		driveBackwardPid(600);
		haultDrive(UH);
		clearLift();
		clearDrive();
		stopTask(liftHolder);

		driveTime(-127, 400);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		haultAll(UH);

		lift2Bottom();
		haultLift(UH);

		// Start 3 star grab

		clearDrive();
		driveForwardPid(110);                            // go forward to not hit fence
		haultDrive(100);
		liftTime(127, 300);
		haultLift(10);
		clearGyro();
		gyroTurn(900, 'l')                                 // Turn Right to line up with stars
		haultDrive(100);

		clearDrive();
		driveForwardPid(1400);                           // Drive into the front three stars
		haultDrive(10);

		pickUp();
		liftTime(127, 400);
		startTask(liftHolder);
		haultDrive(100);


		clearGyro();
		gyroTurn(900, 'r')                                 // Turn Left to line up with fence
		haultDrive(100);

		//clearDrive();
		//driveForwardPid(400);                               // Go forward to have run up room to throw stars further
		//haultDrive(200);

		//clearDrive();
		clearLift();																			  // Score THEM STARS!!!!!!
		stopTask(liftHolder);

		driveTime(-127, 300);
		haultDrive(10);
		lift2Bottom();
		haultAll(UH);
		clearLift();

		score3();
		haultLift(10);

		haultAll(10);
		clearDrive();
		clearLift();
		clearGyro();


		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Autonomous 1");
		displayLCDCenteredString(1, "is running!");

		clearDrive();
		clearGyro();
		clearLift();

		driveBackwardPid(900);
		haultDrive(10);

		openClaw();                                      // Deploy

		liftEnc(60, 10);
		startTask(liftHolder);
		clearGyro();
		gyroTurn(300, 'l');
		haultDrive(10);

		lift2Bottom();
		haultAll(500);                                   // Wait until claw actually falls
		clearDrive();

		driveForwardPid(240);
		haultDrive(20);
		clearGyro();

		gyroTurn(700, 'r');
		haultDrive(10);

		clearDrive();
		stopTask(liftHolder);
		lift2Bottom();
		driveForwardPid(500);
		haultDrive(1000);

		pickUp();

		liftEnc(127, 200);
		startTask(liftHolder);

		clearDrive();
		driveBackwardPid(350);
		haultDrive(10);

		clearGyro();
		gyroTurn(690, 'l', 90);
		haultDrive(10);

		clearDrive();
		driveBackwardPid(700);
		haultDrive(10);

		driveTime(-127, 400);
		haultDrive(10);

		clearLift();

		score3();
		driveTime(-127, 400);
		haultDrive(10);
		haultLift(10);


		haultAll(UH);

		lift2Bottom();
		haultLift(UH);

		clearDrive();
		haultAll(10);

		liftEnc(127, 300);
		startTask(liftHolder);

		clearDrive();
		driveForwardPid(144);
		haultDrive(10);

		clearGyro();
		gyroTurn(900, 'l');
		haultDrive(10);

		stopTask(liftHolder);
		lift2Bottom();
		haultLift(100);

		clearDrive();
		driveForwardPid(200);
		haultDrive(10);

		clearGyro();
		gyroTurn(1100, 'R', 100);
		haultDrive(10);

		clearDrive();
		driveForwardPid(800);
		haultDrive(10);

		pickUp();
		startTask(liftHolder);

		clearDrive();
		driveBackwardPid(600);
		haultDrive(10);

		driveTime(-127, 600);
		haultDrive(10);

		stopTask(liftHolder);

		driveTime(107, 200);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 400);
		haultDrive(10);


		lift2Bottom();
		haultLift(10);

		clearDrive();
		driveForwardPid(900);
		haultDrive(10);

		pickUp();
		startTask(liftHolder);

		clearDrive();
		driveBackwardPid(600);
		haultDrive(10);

		driveTime(-127, 600);
		haultDrive(10);

		stopTask(liftHolder);

		driveTime(107, 200);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 400);
		haultDrive(10);

		lift2Bottom();
		haultLift(10);

		driveTime(-127, 200);
		haultDrive(10);

		clearDrive();
		driveForwardPid(580);                            // Forward to line up with middle cube
		haultDrive(UH);
		clearDrive();
		clearGyro();
		liftTime(127, 450);
		haultLift(10);

		gyroTurn(900, 'r');                              // Turn left to line up with cube
		haultDrive(UH);
		clearDrive();

		driveForwardPid(2700, 110);                        // Drive into Cube
		haultDrive(UH);
		clearDrive();
		pickUp();
		liftTime(127, 500);
																										// Pick cube up
		startTask(liftHolder);

		haultDrive(1000);

		clearGyro();
		gyroTurn(900, 'l');
		haultAll(100);
		motor[driveLeftBack] = 127;
		motor[driveLeftFront] = 127;
		motor[driveRightBack] = -127;
		motor[driveRightFront] = -127;
		wait1msec(20);

		haultDrive(1000);
		clearLift();
		clearDrive();																		 // Turn, back to the fence
    stopTask(liftHolder);

    driveBackwardPid(500);

    driveTime(-127, 300);
		haultDrive(10);
		lift2Bottom();
		haultAll(UH);
		clearLift();

		score3();
		haultLift(10);

    // Score
    haultAll(UH);
    clearDrive();
    lift2Bottom();
		haultLift(UH);
		clearLift();

		liftEnc(50, 127);
		startTask(liftHolder);

		clearGyro();
		gyroTurn(200, 'r', 80);
		haultDrive(10);

		stopTask(liftHolder);
		lift2Bottom();
		haultLift(10);

		clearDrive();
		driveForwardPid(1100);                            // Go for Second Ground Cube plus star
		haultDrive(UH+300);
		pickUp();
		startTask(liftHolder);
		clearDrive();
		driveBackwardPid(800);
		haultDrive(UH);
		clearLift();
		clearDrive();
		stopTask(liftHolder);

		driveTime(-127, 400);
		haultDrive(10);

		driveTime(107, 200);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 400);
		haultDrive(10);

		haultAll(UH);

		lift2Bottom();
		haultLift(UH);


		// take corner star


		clearDrive();
		haultAll(10);

		liftEnc(127, 300);
		startTask(liftHolder);

		clearDrive();
		driveForwardPid(144);
		haultDrive(10);

		clearGyro();
		gyroTurn(900, 'r');
		haultDrive(10);

		stopTask(liftHolder);
		lift2Bottom();
		haultLift(100);

		clearDrive();
		driveForwardPid(200);
		haultDrive(10);

		pickUp();
		startTask(liftHolder);

		clearGyro();
		gyroTurn(900, 'l'); // turn to throw single star from corner
		haultDrive(10);

		driveTime(-127, 400);
		haultDrive(10);

		driveTime(107, 200);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 400);
		haultDrive(10);

		haultAll(UH);

		lift2Bottom();
		haultLift(UH);




		clearDrive();    // 3 stars
		driveForwardPid(450);
		haultDrive(10);

		clearGyro();
		gyroTurn(1200, 'l');
		haultDrive(10);

		clearDrive();    // foward iunbto 3 stars
		driveForwardPid(1400);
		haultDrive(10);


		closeClaw();

		clearGyro();
		gyroTurn(1200, 'r');
		haultDrive(10);

		driveTime(-127, 400);
		haultDrive(10);

		driveTime(107, 200);
		haultDrive(10);

		clearLift();

		score3();
		haultLift(10);

		driveTime(-127, 400);
		haultDrive(10);

		haultAll(UH);

		lift2Bottom();
		haultLift(UH);


		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Left");
		displayLCDCenteredString(1, "is running!");

			clearDrive();
		clearGyro();
		clearLift();

		driveTime(-127, 500);
		haultDrive(10);

		clearDrive();
		driveForwardPid(580);                            // Forward to line up with middle cube
		haultDrive(UH);
		clearDrive();
		clearGyro();
		liftTime(127, 450);
		haultLift(10);
		gyroTurn(900, 'r');                              // Turn left to line up with cube
		haultDrive(UH);
		clearDrive();

		driveForwardPid(2200, 110);                        // Drive into Cube
		haultDrive(UH);
		clearDrive();





		break;

	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while (true)
	{

		clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		wait1Msec(10);

		motor[driveRightFront] = vexRT[Ch2];
		motor[driveRightBack] = vexRT[Ch2];
		motor[driveLeftFront] = vexRT[Ch3];
		motor[driveLeftBack] = vexRT[Ch3];


		if(vexRT[Btn8D] == 1)
			SensorValue(hangLock) = 0;
		else if(vexRT[Btn8U] == 1)
			SensorValue(hangLock) = 1;
	//	else if(vexRT(Btn7U) == 1)
		//	hangFromGround();


		if(SensorValue(liftBottom) == 1)
		{
			nMotorEncoder(liftLeftEnc) = 0;
			nMotorEncoder(liftRightEnc) = 0;
		}

		if(vexRT[Btn5D] == 1 || abs(nMotorEncoder[liftRightEnc]) > releaseThreshold || abs(nMotorEncoder[liftLeftEnc]) > releaseThreshold)
		{
			openClaw();
		}
		else if (vexRT[Btn5U] == 1)
		{
			closeClaw();
		}

		if(vexRT[Btn6U] == 1)
		{
			closeClaw();
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[liftLeftEnc] = -127;
			motor[liftLeftIn] = -127;
			motor[liftLeftTop] = -127;
			motor[liftRightEnc] = -127;
			motor[liftRightIn] = -127;
			motor[liftRightTop] = -127;
		}

		else
		{
			if(SensorValue[liftBottom] == 0)
			{
				motor[liftLeftEnc] = heightThreshold;
				motor[liftLeftIn] = heightThreshold;
				motor[liftLeftTop] = heightThreshold;
				motor[liftRightEnc] = heightThreshold;
				motor[liftRightIn] = heightThreshold;
				motor[liftRightTop] = heightThreshold;
			}
			else
			{
				motor[liftLeftEnc] = -10;
				motor[liftLeftIn] = -10;
				motor[liftLeftTop] = -10;
				motor[liftRightEnc] = -10;
				motor[liftRightIn] = -10;
				motor[liftRightTop] = -10;

			}
		}
	}
}
